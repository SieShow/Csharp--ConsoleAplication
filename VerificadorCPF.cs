using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace ATPresolusao{    class Program    {        static void Main(string[] args)        {            long cpf, cpfor, soma = 0, num, dig1, dig2; //a variável cpf precisa ser long. Por se tratar de 9 digitos que podem chegar até 9, int seria estrapolado            //enquanto long possui valor maximo suficiente            do            {                Console.Write("Digite seu cpf: "); // Essa mensagens será exibida ENQUANTO o cpf for menor que 0 ou maior que 999.999.999                cpf = long.Parse(Console.ReadLine());            } while (cpf < 0 || cpf > 999999999);            cpfor = cpf; //salvo o valor original do cpf em outra variável que será usada depois            for(long i=2; i<=10;i++) //crio uma variável i = para realizar o for. i é = a 2 pq a primeira multiplicação com o digito do cpf começa com ele            {// e vai até 10                num = cpf % 10; //o primeiro número do cpf a ser retirado para multiplicar será igual ao resto da divisão do cpf por 10. Ex: cpf = 123456789.                //123456789 % 10 = 9. "tendeu" huehue                soma += num * i; // a soma vai ser esse número * o i. O valor de i será constantemente acrescentado pelo for.                  //Ex: 9 * 1 => 8 * 2 => 7 * 3... até o fim do cpf                cpf /= 10; //agora o cpf será reduzido para que o primeiro calculo não pegue sempre o msm número. cpf = 123456789 => 12345678 => 1234567 => 123456...            }            dig1 = soma % 11; //o primeiro digito verificador é igual ao resto da soma dividido por 11. Esse calculo dará um valor que será validado            if (dig1 == 0 || dig1 == 1) dig1 = 0; // se ele for igual a 0, não será alterado, se for igual a 1, receberá o valor de 0            else dig1 = 11 - dig1; // se não, será subtraido de 11, e esse será o real valor do digito            cpf = cpfor; //cpf atualmente é igual a 0 graças ao for, como tinha atribuido cpfor = cpf, cpfor está intacto, e atribuo esse valor ao cpf novamente            cpfor = cpfor * 10 + dig1; // cpfor = 123456789, vai passar a ser esse valor vezes 10 + o digito encontrado. Ex: se dig = 0; cpfor = 1234567890            //caso seja feito apenas cpfor = cpfor + dig, o número será 123456789 com dig=0. logo, o cpf não será alterado em caso de dig=0. O objetivo é aumentar a casa decimal            soma = 0; //retorno o valor da soma igual a 0 para que não dê conflito no proximo for            for (long i = 2; i <= 11; i++)            {// a operação é a mesma, contando que agora, o cpf possui 11 digitos                num = cpfor % 10;                soma += num * i;                cpfor /= 10;            }            dig2 = soma % 11;            if (dig2 == 0 || dig2 == 1) dig2 = 0;            else dig2 = 11 - dig2;            Console.Write("Seu cpf é {0}-{1}{2}",cpf, dig1, dig2);            Console.ReadKey();        }    }}